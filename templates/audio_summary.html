{% extends "base.html" %}
{% block title %}Audio Summary{% endblock %}
{% block content %}
<style>
	.audio-page { max-width: 1000px; margin: 0 auto; }
	.audio-card {
		background: #fff;
		border: 1px solid #e2e8f0;
		border-radius: 14px;
		padding: 1rem;
	}
	.summary-box {
		white-space: pre-wrap;
		background: #f8fafc;
		border: 1px solid #e2e8f0;
		border-radius: 10px;
		padding: 0.9rem;
		min-height: 190px;
	}
</style>

<div class="audio-page">
	<div class="page-header-card">
		<h1>ðŸ”Š Audio Summary</h1>
		<p>Paste text or upload one or more readings, then listen to a summary or podcast-style script.</p>
	</div>

	<div class="audio-card mt-3">
		<form id="audioSummaryForm" class="mb-3">
			<div class="mb-2">
				<label class="form-label">Output Mode</label>
				<select id="outputMode" name="mode" class="form-select">
					<option value="summary" selected>Summary (bullets)</option>
					<option value="podcast">Podcast (Host/Guest conversation)</option>
				</select>
			</div>
			<div class="mb-2">
				<label class="form-label">Reading Text</label>
				<textarea id="readingText" name="text" rows="7" class="form-control" placeholder="Paste article or notes here..."></textarea>
			</div>
			<div class="mb-2">
				<label class="form-label">Or Upload Files (TXT/MD/DOCX/PDF)</label>
				<input type="file" id="readingFiles" name="reading_files" class="form-control" accept=".txt,.md,.markdown,.docx,.pdf" multiple>
				<div class="small text-muted mt-1">You can upload multiple files (max 4MB per file, 12MB total). Add files in multiple picks if needed.</div>
				<div id="selectedFilesList" class="small mt-2 text-muted">No files selected yet.</div>
				<div class="mt-2">
					<button type="button" class="btn btn-outline-secondary btn-sm" id="clearFilesBtn">Clear Files</button>
				</div>
			</div>
			<button type="submit" class="btn btn-primary" id="generateBtn">Generate Summary</button>
			<span id="statusText" class="small text-muted ms-2"></span>
		</form>

		<div class="row g-2 mb-2">
			<div class="col-md-3">
				<label class="form-label small mb-1">Playback Engine</label>
				<select id="playbackEngine" class="form-select form-select-sm">
					<option value="auto" selected>Auto (AI then Browser)</option>
					<option value="ai">AI Natural Voice</option>
					<option value="browser">Browser Voice</option>
				</select>
			</div>
			<div class="col-md-3">
				<label class="form-label small mb-1">Browser Voice</label>
				<select id="voiceSelect" class="form-select form-select-sm"></select>
			</div>
			<div class="col-md-3">
				<label class="form-label small mb-1">AI Voice (Single)</label>
				<select id="aiVoiceSingle" class="form-select form-select-sm"></select>
			</div>
			<div class="col-md-3">
				<label class="form-label small mb-1">AI Voice (Host)</label>
				<select id="aiVoiceHost" class="form-select form-select-sm"></select>
			</div>
			<div class="col-md-3">
				<label class="form-label small mb-1">AI Voice (Guest)</label>
				<select id="aiVoiceGuest" class="form-select form-select-sm"></select>
			</div>
			<div class="col-md-2">
				<label class="form-label small mb-1">Speed</label>
				<select id="rateSelect" class="form-select form-select-sm">
					<option value="0.75">0.75x</option>
					<option value="1" selected>1x</option>
					<option value="1.25">1.25x</option>
					<option value="1.5">1.5x</option>
				</select>
			</div>
			<div class="col-md-6 d-flex align-items-end gap-2">
				<button type="button" class="btn btn-outline-primary btn-sm" id="playBtn">Play</button>
				<button type="button" class="btn btn-outline-secondary btn-sm" id="pauseBtn">Pause</button>
				<button type="button" class="btn btn-outline-danger btn-sm" id="stopBtn">Stop</button>
			</div>
		</div>

		<div id="summaryOutput" class="summary-box text-muted">Your summary will appear here.</div>
	</div>
</div>

<script>
	const form = document.getElementById("audioSummaryForm");
	const generateBtn = document.getElementById("generateBtn");
	const statusText = document.getElementById("statusText");
	const summaryOutput = document.getElementById("summaryOutput");
	const voiceSelect = document.getElementById("voiceSelect");
	const playbackEngine = document.getElementById("playbackEngine");
	const aiVoiceSingle = document.getElementById("aiVoiceSingle");
	const aiVoiceHost = document.getElementById("aiVoiceHost");
	const aiVoiceGuest = document.getElementById("aiVoiceGuest");
	const readingFilesInput = document.getElementById("readingFiles");
	const selectedFilesList = document.getElementById("selectedFilesList");
	const clearFilesBtn = document.getElementById("clearFilesBtn");
	const rateSelect = document.getElementById("rateSelect");
	const playBtn = document.getElementById("playBtn");
	const pauseBtn = document.getElementById("pauseBtn");
	const stopBtn = document.getElementById("stopBtn");
	const outputMode = document.getElementById("outputMode");

	let voices = [];
	let currentSummary = "";
	let currentMode = "summary";
	let utterance = null;
	let podcastQueue = [];
	let podcastSpeaking = false;
	let selectedFiles = [];
	let naturalAudio = null;
	let naturalAudioObjectUrl = "";
	const AI_TTS_VOICES = ["alloy", "ash", "ballad", "coral", "echo", "fable", "onyx", "nova", "sage", "shimmer"];

	function loadAiVoices() {
		aiVoiceSingle.innerHTML = "";
		aiVoiceHost.innerHTML = "";
		aiVoiceGuest.innerHTML = "";
		AI_TTS_VOICES.forEach((voiceName) => {
			const pretty = voiceName.charAt(0).toUpperCase() + voiceName.slice(1);
			const singleOpt = document.createElement("option");
			singleOpt.value = voiceName;
			singleOpt.textContent = pretty;
			const hostOpt = singleOpt.cloneNode(true);
			const guestOpt = singleOpt.cloneNode(true);
			aiVoiceSingle.appendChild(singleOpt);
			aiVoiceHost.appendChild(hostOpt);
			aiVoiceGuest.appendChild(guestOpt);
		});
		aiVoiceSingle.value = "alloy";
		aiVoiceHost.value = "alloy";
		aiVoiceGuest.value = "nova";
	}

	function cleanupNaturalAudio() {
		if (naturalAudio) {
			try {
				naturalAudio.pause();
			} catch (error) {}
			naturalAudio = null;
		}
		if (naturalAudioObjectUrl) {
			URL.revokeObjectURL(naturalAudioObjectUrl);
			naturalAudioObjectUrl = "";
		}
	}

	function formatBytes(bytes) {
		if (!bytes || bytes <= 0) return "0 B";
		const units = ["B", "KB", "MB", "GB"];
		let value = bytes;
		let unitIdx = 0;
		while (value >= 1024 && unitIdx < units.length - 1) {
			value /= 1024;
			unitIdx += 1;
		}
		return `${value.toFixed(unitIdx === 0 ? 0 : 1)} ${units[unitIdx]}`;
	}

	function renderSelectedFiles() {
		if (!selectedFiles.length) {
			selectedFilesList.textContent = "No files selected yet.";
			return;
		}
		const totalSize = selectedFiles.reduce((acc, f) => acc + (f.size || 0), 0);
		const names = selectedFiles.map((f) => `${f.name} (${formatBytes(f.size || 0)})`);
		selectedFilesList.textContent = `${selectedFiles.length} file(s): ${names.join(", ")} | Total: ${formatBytes(totalSize)}`;
	}

	readingFilesInput.addEventListener("change", () => {
		const incoming = Array.from(readingFilesInput.files || []);
		if (!incoming.length) return;
		const known = new Set(selectedFiles.map((f) => `${f.name}::${f.size}::${f.lastModified}`));
		incoming.forEach((file) => {
			const key = `${file.name}::${file.size}::${file.lastModified}`;
			if (!known.has(key)) {
				selectedFiles.push(file);
				known.add(key);
			}
		});
		readingFilesInput.value = "";
		renderSelectedFiles();
		statusText.textContent = `${selectedFiles.length} file(s) queued.`;
	});

	clearFilesBtn.addEventListener("click", () => {
		selectedFiles = [];
		readingFilesInput.value = "";
		renderSelectedFiles();
		statusText.textContent = "File queue cleared.";
	});

	function loadVoices() {
		voices = window.speechSynthesis.getVoices();
		voiceSelect.innerHTML = "";
		voices.forEach((voice, idx) => {
			const option = document.createElement("option");
			option.value = String(idx);
			option.textContent = `${voice.name} (${voice.lang})`;
			voiceSelect.appendChild(option);
		});
		const preferredIndices = voices
			.map((voice, idx) => ({ voice, idx }))
			.filter((row) => /^en/i.test(row.voice.lang || ""))
			.map((row) => row.idx);
		if (preferredIndices.length) {
			voiceSelect.value = String(preferredIndices[0]);
		} else if (voiceSelect.options.length > 0) {
			voiceSelect.value = "0";
		}
	}

	if ("speechSynthesis" in window) {
		loadVoices();
		window.speechSynthesis.onvoiceschanged = loadVoices;
	} else {
		statusText.textContent = "Text-to-speech is not supported in this browser.";
	}
	loadAiVoices();

	async function fetchNaturalAudioUrl(text, voiceName) {
		const resp = await fetch("/audio-summary/tts", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({ text, voice: voiceName })
		});
		const data = await resp.json();
		if (!resp.ok || !data.ok || !data.audio_base64) {
			throw new Error(data.error || "Natural voice unavailable.");
		}
		const binary = atob(data.audio_base64);
		const bytes = new Uint8Array(binary.length);
		for (let i = 0; i < binary.length; i += 1) {
			bytes[i] = binary.charCodeAt(i);
		}
		const blob = new Blob([bytes], { type: data.mime_type || "audio/mpeg" });
		return URL.createObjectURL(blob);
	}

	function playUrl(url, playbackRate) {
		return new Promise((resolve, reject) => {
			const audio = new Audio(url);
			naturalAudio = audio;
			audio.playbackRate = playbackRate;
			audio.onended = () => resolve();
			audio.onerror = () => reject(new Error("Audio playback failed."));
			audio.play().catch(reject);
		});
	}

	async function playNaturalPodcastByLine() {
		const lines = currentSummary
			.split("\n")
			.map((line) => line.trim())
			.filter((line) => line);
		if (!lines.length) {
			throw new Error("No podcast script to play.");
		}
		const segments = lines
			.map((line) => {
				const lower = line.toLowerCase();
				const speaker = lower.startsWith("guest:") ? "guest" : "host";
				const text = line.replace(/^host:\s*/i, "").replace(/^guest:\s*/i, "").trim();
				return { speaker, text };
			})
			.filter((item) => item.text);
		if (!segments.length) {
			throw new Error("No podcast lines found.");
		}
		podcastSpeaking = true;
		for (let i = 0; i < segments.length; i += 1) {
			if (!podcastSpeaking) {
				break;
			}
			const item = segments[i];
			const chosenVoice = item.speaker === "guest" ? (aiVoiceGuest.value || "nova") : (aiVoiceHost.value || "alloy");
			statusText.textContent = `Generating natural podcast voice ${i + 1}/${segments.length}...`;
			const url = await fetchNaturalAudioUrl(item.text, chosenVoice);
			naturalAudioObjectUrl = url;
			statusText.textContent = `Playing podcast line ${i + 1}/${segments.length}...`;
			await playUrl(url, Number(rateSelect.value || 1));
			URL.revokeObjectURL(url);
			naturalAudioObjectUrl = "";
			naturalAudio = null;
		}
		podcastSpeaking = false;
		statusText.textContent = "Natural podcast playback finished.";
	}

	function speakSummary() {
		if (!currentSummary) {
			statusText.textContent = "Generate a summary first.";
			return;
		}
		if (!("speechSynthesis" in window)) {
			statusText.textContent = "Text-to-speech is not supported in this browser.";
			return;
		}
		window.speechSynthesis.cancel();
		podcastQueue = [];
		podcastSpeaking = false;
		cleanupNaturalAudio();

		const selectedEngine = (playbackEngine.value || "auto").toLowerCase();
		const canUseNaturalTts = !!window.fetch && !!window.Audio && currentSummary.length <= 6000;
		const useBrowserOnly = selectedEngine === "browser";
		const useAiOnly = selectedEngine === "ai";

		if (!useBrowserOnly && canUseNaturalTts) {
			if (currentMode === "podcast") {
				playNaturalPodcastByLine().catch(() => {
					if (useAiOnly) {
						statusText.textContent = "AI natural podcast playback failed.";
						return;
					}
					statusText.textContent = "Natural podcast unavailable, using browser voices.";
					playWithBrowserVoices();
				});
				return;
			}
			statusText.textContent = "Generating natural voice audio...";
			fetchNaturalAudioUrl(currentSummary, aiVoiceSingle.value || "alloy").then((url) => {
				naturalAudioObjectUrl = url;
				naturalAudio = new Audio(naturalAudioObjectUrl);
				naturalAudio.playbackRate = Number(rateSelect.value || 1);
				naturalAudio.onended = () => {
					statusText.textContent = "Natural voice playback finished.";
				};
				naturalAudio.play().then(() => {
					statusText.textContent = "Playing natural voice audio...";
				}).catch(() => {
					throw new Error("Could not play natural audio.");
				});
			}).catch(() => {
				if (useAiOnly) {
					statusText.textContent = "AI natural voice playback failed.";
					return;
				}
				statusText.textContent = "Natural voice unavailable, using browser voice.";
				playWithBrowserVoices();
			});
			return;
		}

		if (useAiOnly && !canUseNaturalTts) {
			statusText.textContent = "AI natural voice is unavailable for this text length/device.";
			return;
		}

		playWithBrowserVoices();
	}

	function playWithBrowserVoices() {
		window.speechSynthesis.cancel();
		podcastQueue = [];
		podcastSpeaking = false;

		if (currentMode === "podcast") {
			const lines = currentSummary
				.split("\n")
				.map((line) => line.trim())
				.filter((line) => line);
			if (!lines.length) {
				statusText.textContent = "No podcast script to play.";
				return;
			}
			const hostIdx = Number(voiceSelect.value || 0);
			const guestIdx = Math.min(voices.length - 1, hostIdx + 1);
			const hostVoice = voices[hostIdx] || null;
			const guestVoice = voices[guestIdx] || voices[hostIdx] || null;
			podcastQueue = lines.map((line) => {
				const lower = line.toLowerCase();
				const speaker = lower.startsWith("guest:") ? "guest" : "host";
				const text = line.replace(/^host:\s*/i, "").replace(/^guest:\s*/i, "").trim();
				return { speaker, text };
			}).filter((item) => item.text);
			let index = 0;
			podcastSpeaking = true;
			const speakNext = () => {
				if (!podcastSpeaking || index >= podcastQueue.length) {
					podcastSpeaking = false;
					statusText.textContent = "Podcast finished.";
					return;
				}
				const item = podcastQueue[index++];
				const part = new SpeechSynthesisUtterance(item.text);
				part.voice = item.speaker === "guest" ? guestVoice : hostVoice;
				const selectedRate = Number(rateSelect.value || 1);
				part.rate = Math.min(1.05, selectedRate);
				part.pitch = item.speaker === "guest" ? 1.08 : 0.96;
				part.onend = speakNext;
				part.onerror = speakNext;
				window.speechSynthesis.speak(part);
			};
			statusText.textContent = "Playing podcast (browser voices)...";
			speakNext();
			return;
		}

		utterance = new SpeechSynthesisUtterance(currentSummary);
		const selectedIdx = Number(voiceSelect.value || 0);
		if (voices[selectedIdx]) {
			utterance.voice = voices[selectedIdx];
		}
		utterance.rate = Number(rateSelect.value || 1);
		window.speechSynthesis.speak(utterance);
		statusText.textContent = "Playing summary (browser voice)...";
	}

	form.addEventListener("submit", async (event) => {
		event.preventDefault();
		const payload = new FormData();
		payload.append("mode", outputMode.value || "summary");
		payload.append("text", document.getElementById("readingText").value || "");
		if (selectedFiles.length) {
			selectedFiles.forEach((file) => payload.append("reading_files[]", file, file.name));
		} else {
			Array.from(readingFilesInput.files || []).forEach((file) => payload.append("reading_files[]", file, file.name));
		}
		generateBtn.disabled = true;
		statusText.textContent = "Generating summary...";
		try {
			const response = await fetch("/audio-summary", {
				method: "POST",
				body: payload
			});
			const data = await response.json();
			if (!response.ok || !data.ok) {
				throw new Error(data.error || "Failed to generate summary.");
			}
			currentSummary = data.summary || "";
			currentMode = data.mode || outputMode.value || "summary";
			summaryOutput.textContent = currentSummary || "No summary returned.";
			summaryOutput.classList.remove("text-muted");
			statusText.textContent = currentMode === "podcast" ? "Podcast script ready." : "Summary ready.";
		} catch (error) {
			statusText.textContent = error.message || "Failed to generate summary.";
		} finally {
			generateBtn.disabled = false;
		}
	});

	playBtn.addEventListener("click", speakSummary);
	pauseBtn.addEventListener("click", () => {
		if (naturalAudio) {
			naturalAudio.pause();
			statusText.textContent = "Paused.";
			return;
		}
		if ("speechSynthesis" in window) {
			window.speechSynthesis.pause();
			statusText.textContent = "Paused.";
		}
	});
	stopBtn.addEventListener("click", () => {
		cleanupNaturalAudio();
		if ("speechSynthesis" in window) {
			podcastSpeaking = false;
			podcastQueue = [];
			window.speechSynthesis.cancel();
			statusText.textContent = "Stopped.";
		}
	});
</script>
{% endblock %}
